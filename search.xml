<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>今日感慨</title>
      <link href="%E4%BB%8A%E6%97%A5%E6%84%9F%E6%85%A8/"/>
      <url>%E4%BB%8A%E6%97%A5%E6%84%9F%E6%85%A8/</url>
      
        <content type="html"><![CDATA[<p>好久没有记录生活了，难得搭起了博客，就写一写叭。 虽然用了大佬云游君的Theme，但是自己补插件也是花了不少心思。想想已经两天没有学习mybatis了呢，汗颜。😓</p><p>收获还是挺多的呢，最重要的就是想起了学IT的初衷，毕竟宅宅的我从一开始还是透过电脑观察世界来着。所以我的世界总围着电脑转（害，游戏太香了），感觉二进制的世界和三次元在我心里是划等号的。嘛，回忆起了初衷，感觉斗志满满，想学习了奥。✊</p><p>而且在搭建博客的时候，学到了好多知识，比如</p><ul><li><p>合理的使用API（搜索引擎、W留言+V留言、全局音乐播放器</p></li><li><p>Git Issue &amp; Git Discussion</p></li><li><p>阅读各种doc</p></li><li><p>提高了对环境变量的理解和命令行熟练度</p></li><li><p>复习了一点CSS的知识</p></li><li><p>提高了一点点对Git的理解（虽然还是不及格😀</p><ul><li><p>Git各种分支平台，虽然工具都是GIt，但是数据不互通</p><ul><li>.git文件夹的config里记录着对应的Repository</li><li>.gitignore文件里记录着不需要push的文件目录</li></ul></li></ul></li><li><p>提高了亿点点对包管理工具的理解</p><ul><li>原来npm是Node.js自带的包管理工具</li><li>难怪在装Nodejs的时候配置了环境变量</li><li><code>$ npm --save</code>的命令其实是把安装过的包记录在了<code>package.json</code>文件里，像<code>.pom</code>文件一样</li></ul></li><li><p>还有对markdown使用越来越熟练了</p></li></ul><p>最终搭出了一个漂漂亮亮的树洞记录心情和知识，感觉成就感Max</p><p>今后也要不断进步</p><p align="right">Always feel happy and keep moving-----Moka☆君</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 日记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>algolia</title>
      <link href="algolia/"/>
      <url>algolia/</url>
      
        <content type="html"><![CDATA[<p>目的：<br>想在Hexo博客上搭载本地搜索引擎，发现网上流程错误过多，且对生成的API权限范围错误太多，故留文。</p><p>首先想在Hexo引用algolia有 <a href="https://github.com/oncletom/hexo-algolia">hexo-algolia</a>或 <a href="https://github.com/LouisBarranqueiro/hexo-algoliasearch">hexo-algoliasearch</a>两种对应插件，安装一种即可</p><p>我安装的是hexo-algolia，所以以下algolia均是针对此插件</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --save hexo-algolia</span><br></pre></td></tr></table></figure><h2 id="Public-Facing-Search-Options"><a href="#Public-Facing-Search-Options" class="headerlink" title="Public Facing Search Options"></a>Public Facing Search Options</h2><p>You can configure Algolia integration to your hexo website with the <code>_config.yml</code> file:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">algolia:</span><br><span class="line">  applicationID: &#x27;applicationID&#x27;</span><br><span class="line">  apiKey: &#x27;apiKey&#x27;</span><br><span class="line">  indexName: &#x27;...&#x27;</span><br></pre></td></tr></table></figure><table><thead><tr><th>Config Key</th><th></th></tr></thead><tbody><tr><td><code>applicationID</code></td><td>Your Algolia Application ID</td></tr><tr><td><code>apiKey</code></td><td>A <strong>Search-Only</strong> API key</td></tr><tr><td><code>indexName</code></td><td>The name of the Algolia index to use</td></tr></tbody></table><p>注意这里的apiKey是 <strong>Search-Only</strong> API key，他是普通访问者搜索时调用的API key。</p><h3 id="Adds-the-Algolia-search-client"><a href="#Adds-the-Algolia-search-client" class="headerlink" title="Adds the Algolia search client"></a>Adds the <a href="https://www.algolia.com/doc/api-client/javascript/">Algolia search client</a></h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install algoliasearch</span><br></pre></td></tr></table></figure><p>需要安装 Algolia JavaScript API Client</p><h3 id="Edit-API-Key"><a href="#Edit-API-Key" class="headerlink" title="Edit API Key"></a>Edit API Key</h3><p>我们还需要一个API Key来对内容的索引进行上传。 因为这个搜索引擎的本质就是根据我们的Hexo博客生成索引上传到第三方服务器。我们每次搜索实际上是在搜服务器的索引。</p><p>hexo algolia指令其实是使用这个API来进行索引的上传和修改，我们需要将这个API设为环境变量以供指令调用。</p><p>我们需要在Algolia官网上new 一个 API：</p><p>登陆官网–&gt; API Keys –&gt;All API Keys –&gt; New API key</p><p><img src="https://i.loli.net/2021/06/02/SRolr7g5DwveN2L.png" alt="image-20210602161511576" loading="lazy"></p><p>Create it with <strong>these limited write access</strong> permissions: <code>Add records</code>, <code>Delete records</code>, <code>List indices</code>, <code>Delete index</code>.</p><p><img src="https://i.loli.net/2021/06/02/7Bo9ginL4NeqIEu.png" alt="image-20210602160901950" loading="lazy"></p><p>然后我们需要将<strong>这个API</strong>加入环境变量，下面是官方doc原文：</p><p>A separate <em>API Key</em> must be provided as an <strong>environment variable</strong> named <code>HEXO_ALGOLIA_INDEXING_KEY</code>. </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export HEXO_ALGOLIA_INDEXING_KEY=…</span><br><span class="line">$ ./node_modules/.bin/hexo algolia</span><br></pre></td></tr></table></figure><p><strong>问题出现了，export指令时linux设置环境变量使用的。Windows CMD和Power Shell无法使用。所以我们需要直接去设置环境变量 HEXO_ALGOLIA_INDEXING_KEY 和对应的API KEY</strong></p><p>设置好之后（可能需要重启），在博客根目录即可使用<code>hexo algolia</code>来自动生成并上传索引了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo algolia</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Test</title>
      <link href="Test/"/>
      <url>Test/</url>
      
        <content type="html"><![CDATA[<p><strong>对象：</strong></p><p>Test</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo添加分类及标签</title>
      <link href="Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/"/>
      <url>Hexo%E6%B7%BB%E5%8A%A0%E5%88%86%E7%B1%BB%E5%8F%8A%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-添加分类及标签"><a href="#Hexo-添加分类及标签" class="headerlink" title="Hexo 添加分类及标签"></a>Hexo 添加分类及标签</h1><blockquote><p>生成的新文件夹都在source下也就是和放文章的文件夹一块 以下所有命令都是在博客文件目录下执行</p></blockquote><h4 id="1-创建“分类”选项"><a href="#1-创建“分类”选项" class="headerlink" title="1. 创建“分类”选项"></a>1. 创建“分类”选项</h4><p>生成“分类”页并添加tpye属性,进入博客目录。执行命令下方命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>categories文件夹下会有index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2019-04-22 14:47:40</span><br><span class="line">---</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>添加type: “categories”到内容中，添加后是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2019-04-24 15:30:30</span><br><span class="line">type: categories</span><br><span class="line">---</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><p>给文章添加“categories”属性</p><p>打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: Hexo</span><br><span class="line">---</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p><h4 id="2-创建“标签”选项"><a href="#2-创建“标签”选项" class="headerlink" title="2. 创建“标签”选项"></a>2. 创建“标签”选项</h4><p>生成“标签”页并添加tpye属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page tags</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>在tags文件夹下，找到index.md这个文件，打开后默认内容是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2019-04-22 14:22:08</span><br><span class="line">---</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>添加type: “tags”到内容中，添加后是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2019-04-24 15:40:24</span><br><span class="line">type: tags</span><br><span class="line">---</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure><p>保存并关闭文件。</p><p>给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo 添加分类及标签</span><br><span class="line">date: 2019-04-24 15:40:24</span><br><span class="line">categories: </span><br><span class="line">- Hexo</span><br><span class="line">tags:</span><br><span class="line">- 博客</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>getResource方法</title>
      <link href="getResource%E6%96%B9%E6%B3%95%E5%8F%8A%E8%B7%AF%E5%BE%84%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>getResource%E6%96%B9%E6%B3%95%E5%8F%8A%E8%B7%AF%E5%BE%84%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="getResource-方法及路径的理解"><a href="#getResource-方法及路径的理解" class="headerlink" title="getResource()方法及路径的理解"></a>getResource()方法及路径的理解</h3><p>用JAVA获取文件，听似简单，用JAVA的File类，如要取得c:/test.txt文件，就会这样用File file = new File(“c:/test.txt”);</p><p>这样用有什么问题，相信大家都知道，就是路径硬编码，对于JAVA精神来说，应用应该一次成型，到处可用，并且从现实应用来讲，最终生成的应用也会部署到Windows外的操作系统中，对于linux来说，在应用中用了c:/这样的字样，就是失败.</p><p>所以，我们应该尽量避免使用硬编码，不要直接使用绝对路径。</p><span id="more"></span><p>在Servlet应用中，有一个getRealPath(String str)的方法，这个方法尽管也可以动态地获得文件的路径，不秘直接手写绝对路径，但这也是一个不被建议使用的方法，那么，我们有什么方法可以更好地获得文件呢?</p><p>那就是Class.getResource()与Class.getResourceAsStream()方法，但很多人还是不太懂它的用法，也不知道应该传怎么样的参数给它。</p><p>比如我们有以下目录</p><p>|–project</p><pre><code>  |--src              |--javaapplication                        |--Test.java                        |--file1.txt              |--file2.txt    |--build               |--javaapplication                        |--Test.class                        |--**file3.txt**              |--**file4.txt**</code></pre><p>在上面的目录中，有一个src目录，这是JAVA源文件的目录，有一个build目录，这是JAVA编译后文件(.class文件等）的存放目录</p><p>那么，我们在Test类中应该如何分别获得</p><p>file1.txt file2.txt file3.txt file4.txt这四个文件呢？</p><p>首先讲<strong>file3.txt</strong>与<strong>file4.txt</strong></p><p>file3.txt:</p><p>方法一：File file3 = new File(Test.class.getResource(“file3.txt”).getFile());</p><p>方法二：File file3 = new File(Test.class.getResource(“/javaapplication/file3.txt”).getFile());</p><p>方法三：File file3 = new File(Test.class.getClassLoader().getResource(“javaapplication/file3.txt”).getFile());</p><p>file4.txt:</p><p>方法一：File file4 = new File(Test.class.getResource(“/file4.txt”).getFile());</p><p>方法二：File file4 = new File(Test.class.getClassLoader().getResource(“file4.txt”).getFile());</p><p>很好，我们可以有多种方法选择，但是file1与file2文件呢？如何获得？</p><p>答案是，你只能写上它们的绝对路径，不能像file3与file4一样用class.getResource()这种方法获得，它们的获取方法如下</p><h3 id="关于参数"><a href="#关于参数" class="headerlink" title="关于参数"></a>关于参数</h3><p>至于getResouce(String path)方法的参数，基本是两种写法</p><ol><li><p>第一种: “/“为起点</p><p> 这是以编译的根目录为起点，至于它的根目录嘛，<del>你用不同的IDE build出来是不同的位置下的。</del></p><p> 假如build是编译根目录“/”，build目录下面有一个file.txt文件，它的相对路径就是”/file.txt”，</p></li><li><p>第二种: 直接写路径，第一位不是“/”</p><p> 如果相对路径不是以”/“开头，那么它就是相对于调用此方法的Class编译路径。</p><p> 就是你想获得文件，你得从调用它getResource方法的最终生成的(Test.class)文件为着手点，不要以.java文件的路径为出发点，真正使用的就是Test.class，因为java是编译型语言嘛。至于为什么运行时类 <code>Test.class</code>和<code>Test.Class字节码文件</code>在同一处，是因为运行时类就是类加载器生成的Clazz就是记录在字节码文件里呀。。。</p></li></ol><hr><p>注：还有一个getResourceAsStream()方法，参数是与getResouce()方法是一样的，它相当于你用getResource()取得File文件后，再new InputStream(file)一样的结果</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 类加载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类加载器</title>
      <link href="%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
      <url>%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载器负责加载所有的类，其为所有被载入内存中的类生成一个java.lang.Class实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。在Java中，一个类用其全限定类名（包括包名和类名）作为标识；但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例kl负责加载，则该Person类对应的Class对象在JVM中表示为(Person.pg.kl)。</p><p>JVM预定义有三种类加载器，当一个 JVM启动的时候，Java开始使用如下三种类加载器：</p><p>前面两个用不到，了解即可。</p><p><img src="https://i.loli.net/2021/06/01/tn3CJlrbPSps6ko.png" alt="image-20210601191615726" loading="lazy"></p><ol><li><p><strong>根类加载器</strong>:它用来加载 Java 的核心类，是用原生代码来实现的，并不继承自 java.lang.ClassLoader（负责加载$JAVA_HOME中**jre/lib/**的各种类,比如String，Integer等。由C++实现，不是ClassLoader子类），涉及底层我们也调不出来，直接是null。</p></li><li><p><strong>扩展类加载器</strong>：它负责加载JRE的扩展目录，加载<strong>lib/ext</strong>的各种类。由Java语言实现。</p></li><li><p><strong>应用/系统加载器</strong>这个才是我们通常用的ClassLoader。</p><p> 被称为系统（也称为应用）类加载器，程序可以通过ClassLoader的静态方法getSystemClassLoader()来获取系统类加载器。或者.class.getClassLoader().</p><p> 如果没有特别指定，则用户自定义的类加载器都以此类加载器作为父加载器。由Java语言实现。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Object a = String.class.getClassLoader();   <span class="comment">//根加载器 null</span></span><br><span class="line">Object b = Integer.class.getClassLoader();  <span class="comment">//根加载器 null</span></span><br><span class="line">Object c = Account.class.getClassLoader(); <span class="comment">//系统类加载器$AppClassLoader@18b4aac2</span></span><br><span class="line">Object d = Boss.class.getClassLoader(); <span class="comment">//系统类加载器$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">ClassLoader classLoader=ClassLoader.getSystemClassLoader();</span><br><span class="line">System.out.println(<span class="string">&quot;系统加载器：&quot;</span>+classLoader); <span class="comment">//sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"></span><br><span class="line">ClassLoader parentLoader=classLoader.getParent();</span><br><span class="line">System.out.println(<span class="string">&quot;扩展类加载器：&quot;</span>+parentLoader); <span class="comment">//sun.misc.Launcher$ExtClassLoader@7f31245a</span></span><br><span class="line"></span><br><span class="line">ClassLoader rootLoader =parentLoader.getParent();</span><br><span class="line">System.out.println(<span class="string">&quot;根加载器：&quot;</span>+rootLoader);  <span class="comment">//null</span></span><br></pre></td></tr></table></figure><p>通过代码我们能发现，JVM中加载器一共就这几种，没有其他的，因为不同的自定义类用了相同的系统加载器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//关于类加载器的一个重要方法：</span><br><span class="line">InputStream in = Test.class.getResourceAsStream(&quot;xxxx.txt&quot;);</span><br></pre></td></tr></table></figure><p>不理解.class.getResourceAsStream(“xxxx.txt”)请移步至</p><p>1.JVM的类加载机制主要有如下3种。</p><ul><li>全盘负责：所谓全盘负责，就是当一个类加载器负责加载某个Class时，该Class所依赖和引用其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入。</li><li><strong>双亲委派</strong>：所谓的双亲委派，则是先让父类加载器试图加载该Class，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。通俗的讲，就是某个特定的类加载器在接到加载类的请求时，首先将加载任务委托给父加载器，依次递归，如果父加载器可以完成类加载任务，就成功返回；只有父加载器无法完成此加载任务时，才自己去加载。</li><li>缓存机制。缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，类加载器先从缓存区中搜寻该Class，只有当缓存区中不存在该Class对象时，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓冲区中。这就是为很么修改了Class后，必须重新启动JVM，程序所做的修改才会生效的原因。<br>  2.这里说明一下双亲委派机制：</li></ul><p><img src="https://i.loli.net/2021/06/01/OcnU2EwFa5BQbNo.png" alt="img" loading="lazy"></p><p>双亲委派机制，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己才想办法去完成。</p><p>双亲委派机制的优势：采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为java.lang.Integer的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的java.lang.Integer，而直接返回已加载过的Integer.class，这样便可以防止核心API库被随意篡改。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 类加载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>锁机制</title>
      <link href="%E9%94%81%E6%9C%BA%E5%88%B6/"/>
      <url>%E9%94%81%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p><strong>对象：</strong></p><p>对象头记录锁类型和对应线程和对应的Class，实际数据，对象尾部补全数据</p><p><strong>对象头：</strong></p><p>分为Mark Word记录类型和对应线程和GC标志，class point区域记录该对象对应的Class<br>锁其实就是使用对象的对象头</p><p><strong>对象尾部：</strong></p><p>补全字节</p><span id="more"></span><p><img src="https://i.loli.net/2021/05/31/rAf5VoPH7qRIDpK.png" alt="image-20210531020341854" loading="lazy"></p><p>synchronized编译为字节码文件.class后</p><p>其实就是monitor/monitor exit，这个方法会调用系统的线程指令lock，非常占用系统性能</p><p>monitor/monitor exit相当于一个只能容纳一个线程的房间</p><p>entrySet是等待进入的线程们，waitSet是休眠待唤醒的线程们（这些线程被OS挂起，不占用cpu资源，但是唤醒会占用大量资源，甚至大于执行本身）</p><p>房间内每次出入都是一次由操作系统进行调度的线程挂起或连接，非常占用系统性能</p><p><img src="https://i.loli.net/2021/05/31/PntMcBvR7YdCNe8.png" alt="image-20210531015736005" loading="lazy"></p><p>进程的堆是所有线程共享的，每个线程的栈是线程独有的</p><p>所以我们应该使用堆中的对象来作为锁的条件（堆中的对象头来作为 monitor限制线程的房间）</p><p>在java6之后 我们对synchronized这种互斥锁/悲观锁 进行了优化</p><p>使作为房间限制的对象头，也就是锁，有了四种状态：</p><p>无锁       ：任何线程都可以调用</p><hr><p>偏向锁     ：被唯一线程占用（偏爱某一线程），对象头中记载着调用这个对象的线程ID</p><hr><p>轻量级     ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当偏向锁对象发现，有不是头中记载的线程ID的其他线程尝试获取它时，升级为轻量级锁</span><br><span class="line">当线程发现自己调用的是轻量级锁，且调用成功时，就会在栈中生成一块叫做 lock record的空间</span><br><span class="line">空间存放 对象头中Mark Word的副本，以及，owner指针（指针指向锁对象）</span><br><span class="line">与此同时，锁对象的头部会把偏向锁的线程ID替换为指向调用线程的指针</span><br><span class="line">这样 线程和锁对象就确定了彼此关系，确定了锁</span><br><span class="line"></span><br><span class="line">此时如果有其他线程想调用这个锁对象，会进行自旋等待</span><br><span class="line">自旋区别于被操作系统挂起，它是一直循环查看锁有没有被释放，如果锁很快释放的话，自旋就不需要进行系统中断和唤醒</span><br><span class="line">它相当于cpu在空转</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/31/fj1WIQVliBX5byz.png" alt="image-20210531015909253" loading="lazy"></p><hr><p>重量级锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当自旋等待的线程超过一个，对象锁就会升级为重量级锁</span><br><span class="line">重量级锁就是优化前的挂起和唤醒制度，需要monitor来对线程进行控制，效率极低</span><br><span class="line">此时完全锁定资源，非调用者进入休眠状态</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> 线程 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>索引优化</title>
      <link href="%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/"/>
      <url>%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="最左前缀原理与相关优化"><a href="#最左前缀原理与相关优化" class="headerlink" title="最左前缀原理与相关优化"></a>最左前缀原理与相关优化</h2><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p><p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p><p>以employees.titles表为例，下面先查看其上都有哪些索引：</p><span id="more"></span><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> employees.titles;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> emp_no      <span class="operator">|</span> A         <span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span>            <span class="number">2</span> <span class="operator">|</span> title       <span class="operator">|</span> A         <span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span>            <span class="number">3</span> <span class="operator">|</span> from_date   <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">443308</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> emp_no   <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> emp_no      <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">443308</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span></span><br></pre></td></tr></table></figure><p>从结果中可以到titles表的主索引为&lt;emp_no, title, from_date&gt;，还有一个辅助索引<emp_no>。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees.titles <span class="keyword">DROP</span> INDEX emp_no;</span><br></pre></td></tr></table></figure><p>这样就可以专心分析索引PRIMARY的行为了。</p><h3 id="情况一：全列匹配。"><a href="#情况一：全列匹配。" class="headerlink" title="情况一：全列匹配。"></a>情况一：全列匹配。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> title<span class="operator">=</span><span class="string">&#x27;Senior Engineer&#x27;</span> <span class="keyword">AND</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> titles <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">59</span>      <span class="operator">|</span> const,const,const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span></span><br></pre></td></tr></table></figure><p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span> <span class="keyword">AND</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> title<span class="operator">=</span><span class="string">&#x27;Senior Engineer&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>               <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> titles <span class="operator">|</span> const <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">59</span>      <span class="operator">|</span> const,const,const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span></span><br></pre></td></tr></table></figure><p>效果是一样的。</p><h3 id="情况二：最左前缀匹配。"><a href="#情况二：最左前缀匹配。" class="headerlink" title="情况二：最左前缀匹配。"></a>情况二：最左前缀匹配。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> titles <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span>       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</span></span><br></pre></td></tr></table></figure><p>当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或&lt;emp_no, title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p><h3 id="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"><a href="#情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。" class="headerlink" title="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"></a>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>   <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> titles <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> const <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p><p>首先我们看下title一共有几种不同的值：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span>(title) <span class="keyword">FROM</span> employees.titles;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> title              <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br><span class="line"><span class="operator">|</span> Senior Engineer    <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Staff              <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Engineer           <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Senior Staff       <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Assistant Engineer <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Technique Leader   <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> Manager            <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------------------+</span></span><br></pre></td></tr></table></figure><p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles</span><br><span class="line"><span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> title <span class="keyword">IN</span> (<span class="string">&#x27;Senior Engineer&#x27;</span>, <span class="string">&#x27;Staff&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>, <span class="string">&#x27;Senior Staff&#x27;</span>, <span class="string">&#x27;Assistant Engineer&#x27;</span>, <span class="string">&#x27;Technique Leader&#x27;</span>, <span class="string">&#x27;Manager&#x27;</span>)</span><br><span class="line"><span class="keyword">AND</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> titles <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">59</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">7</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILES;</span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+-------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span> Query_ID <span class="operator">|</span> Duration   <span class="operator">|</span> Query                                                                         <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+-------------------------------------------------------------------------------+</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">10</span> <span class="operator">|</span> <span class="number">0.00058000</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span><span class="operator">|</span></span><br><span class="line"><span class="operator">|</span>       <span class="number">11</span> <span class="operator">|</span> <span class="number">0.00052500</span> <span class="operator">|</span> <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> title <span class="keyword">IN</span> ...          <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----------+------------+-------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure><p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p><h3 id="情况四：查询条件没有指定索引第一列。"><a href="#情况四：查询条件没有指定索引第一列。" class="headerlink" title="情况四：查询条件没有指定索引第一列。"></a>情况四：查询条件没有指定索引第一列。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> from_date<span class="operator">=</span><span class="string">&#x27;1986-06-26&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> type <span class="operator">|</span> possible_keys <span class="operator">|</span> key  <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span>   <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> titles <span class="operator">|</span> <span class="keyword">ALL</span>  <span class="operator">|</span> <span class="keyword">NULL</span>          <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="keyword">NULL</span>    <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span> <span class="number">443308</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span></span><br></pre></td></tr></table></figure><p>由于不是最左前缀，索引这样的查询显然用不到索引。</p><h3 id="情况五：匹配某列的前缀字符串。"><a href="#情况五：匹配某列的前缀字符串。" class="headerlink" title="情况五：匹配某列的前缀字符串。"></a>情况五：匹配某列的前缀字符串。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no<span class="operator">=</span><span class="string">&#x27;10001&#x27;</span> <span class="keyword">AND</span> title <span class="keyword">LIKE</span> <span class="string">&#x27;Senior%&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> titles <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">56</span>      <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>    <span class="number">1</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>此时可以用到索引，<del>但是如果通配符不是只出现在末尾，则无法使用索引。</del>（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p><h3 id="情况六：范围查询。"><a href="#情况六：范围查询。" class="headerlink" title="情况六：范围查询。"></a>情况六：范围查询。</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN <span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> employees.titles <span class="keyword">WHERE</span> emp_no <span class="operator">&lt;</span> <span class="string">&#x27;10010&#x27;</span> <span class="keyword">and</span> title<span class="operator">=</span><span class="string">&#x27;Senior Engineer&#x27;</span>;</span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span> id <span class="operator">|</span> select_type <span class="operator">|</span> <span class="keyword">table</span>  <span class="operator">|</span> type  <span class="operator">|</span> possible_keys <span class="operator">|</span> key     <span class="operator">|</span> key_len <span class="operator">|</span> <span class="keyword">ref</span>  <span class="operator">|</span> <span class="keyword">rows</span> <span class="operator">|</span> Extra       <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span></span><br><span class="line"><span class="operator">|</span>  <span class="number">1</span> <span class="operator">|</span> SIMPLE      <span class="operator">|</span> titles <span class="operator">|</span> <span class="keyword">range</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>       <span class="operator">|</span> <span class="keyword">PRIMARY</span> <span class="operator">|</span> <span class="number">4</span>       <span class="operator">|</span> <span class="keyword">NULL</span> <span class="operator">|</span>   <span class="number">16</span> <span class="operator">|</span> <span class="keyword">Using</span> <span class="keyword">where</span> <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span></span><br></pre></td></tr></table></figure><p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titlesWHERE emp_no &lt; &#x27;10010&#x27;AND title=&#x27;Senior Engineer&#x27;AND from_date BETWEEN &#x27;1986-01-01&#x27; AND &#x27;1986-12-31&#x27;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles</span><br><span class="line">WHERE emp_no BETWEEN &#x27;10001&#x27; AND &#x27;10010&#x27;</span><br><span class="line">AND title=&#x27;Senior Engineer&#x27;</span><br><span class="line">AND from_date BETWEEN &#x27;1986-01-01&#x27; AND &#x27;1986-12-31&#x27;;</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |</span><br><span class="line">+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure><p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p><h3 id="情况七：查询条件中含有函数或表达式。"><a href="#情况七：查询条件中含有函数或表达式。" class="headerlink" title="情况七：查询条件中含有函数或表达式。"></a>情况七：查询条件中含有函数或表达式。</h3><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no=&#x27;10001&#x27; AND left(title, 6)=&#x27;Senior&#x27;;</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br></pre></td></tr></table></figure><p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1=&#x27;10000&#x27;;</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |</span><br><span class="line">+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure><p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p><h2 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h2><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p><p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p><p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p><p>Index Selectivity = Cardinality / #T</p><p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(title))/count(*) AS Selectivity FROM employees.titles;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.0000 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p><p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p><p>从图12可以看到employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.employees WHERE first_name=&#x27;Eric&#x27; AND last_name=&#x27;Anido&#x27;;</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span><br><span class="line">|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |</span><br><span class="line">+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure><p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(first_name))/count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.0042 |</span><br><span class="line">+-------------+</span><br><span class="line">SELECT count(DISTINCT(concat(first_name, last_name)))/count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9313 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p><first_name>显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 3))))/count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.7879 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT count(DISTINCT(concat(first_name, left(last_name, 4))))/count(*) AS Selectivity FROM employees.employees;</span><br><span class="line">+-------------+</span><br><span class="line">| Selectivity |</span><br><span class="line">+-------------+</span><br><span class="line">|      0.9007 |</span><br><span class="line">+-------------+</span><br></pre></td></tr></table></figure><p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE employees.employees</span><br><span class="line">ADD INDEX `first_name_last_name4` (first_name, last_name(4));</span><br></pre></td></tr></table></figure><p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SHOW PROFILES;</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">| Query_ID | Duration   | Query                                                                           |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br><span class="line">|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name=&#x27;Eric&#x27; AND last_name=&#x27;Anido&#x27; |</span><br><span class="line">|       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name=&#x27;Eric&#x27; AND last_name=&#x27;Anido&#x27; |</span><br><span class="line">+----------+------------+---------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure><p>性能的提升是显著的，查询速度提高了120多倍。</p><p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p><h2 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h2><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p><p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p><p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p><p><img src="https://i.loli.net/2021/05/31/r8OPfaNJxmknSXz.png" alt="img" loading="lazy"></p><p>图13</p><p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置：</p><p><img src="https://i.loli.net/2021/05/31/ab5RKWzSgeNx8Bo.png" alt="img" loading="lazy"></p><p>图14</p><p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p><p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>各种报错汇总</title>
      <link href="%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB/"/>
      <url>%E5%90%84%E7%A7%8D%E6%8A%A5%E9%94%99%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="Tomcat部署问题："><a href="#Tomcat部署问题：" class="headerlink" title="Tomcat部署问题："></a>Tomcat部署问题：</h3><h4 id="HTTP-Status-500-–-Internal-Server-Error"><a href="#HTTP-Status-500-–-Internal-Server-Error" class="headerlink" title="HTTP Status 500 – Internal Server Error"></a>HTTP Status 500 – Internal Server Error</h4><p><strong>Exception</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jakarta.servlet.ServletException: 实例化Servlet类[org.springframework.web.servlet.DispatcherServlet]异常</span><br></pre></td></tr></table></figure><p><strong>Root Cause</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NoClassDefFoundError: javax/servlet/http/HttpServlet</span><br></pre></td></tr></table></figure><p>血的教训，错误：HTTP Status 500-Internal Server Error，报错内容是无法实例化servlet。原因是Tomcat10中的Servlet-api依赖包与Maven导入的Servlet不兼容所致。</p><p>解决方法：</p><p> 直接降级到9就好了。（真的是脑瘫）</p><span id="more"></span><h3 id="文件名中文乱码"><a href="#文件名中文乱码" class="headerlink" title="文件名中文乱码"></a>文件名中文乱码</h3><p>先说结论，不同于消息转换器，我们还需要设置一个过滤器来把request设置成utf-8</p><p>在web.xml里设置，注意放在servlet标签前</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span></span><br><span class="line">    org.springframework.web.filter.CharacterEncodingFilter</span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>forceEncoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过阅读CommonsMultipartResolver源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> String <span class="title">determineEncoding</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">    String encoding = request.getCharacterEncoding();</span><br><span class="line">    <span class="keyword">if</span> (encoding == <span class="keyword">null</span>) &#123;</span><br><span class="line">        encoding = <span class="keyword">this</span>.getDefaultEncoding();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> encoding;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况原因是CommonsMultipartResolver这个文件解析器的编码方式是从request来get编码格式的。</p><p>所以我们可以通过更改request的编码格式，或者强行改变CommonsMultipartResolver的编码格式两种方法来避免中文乱码。后者治标不治本，方法如下：</p><p>需要检查<br>xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;multipartResolver&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">p:defaultEncoding</span>=<span class="string">&quot;UTF-8&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">p:maxUploadSize</span>=<span class="string">&quot;5400000&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">p:uploadTempDir</span>=<span class="string">&quot;fileUpload/temp&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure><p>里面是不是配置了utf-8，因为默认是iso编码（这种情况request.getCharacterEncoding获得值是null,其实就是ISO编码）。<br>其次需要就检查文件上传的那个jsp页面编码里面的编码。包括pageCode,charset和head标签中meta编码最好都是utf-8编码。其他的想tomcat的 server.xml和项目的web.xml都是可以直接使用默认（有网友指出这两个地方需要修改，亲测这两个我都没改，只是保证了CommonsMultipartResolver和jsp页面编码就ok了）。</p><h3 id="EL表达式无法读取"><a href="#EL表达式无法读取" class="headerlink" title="EL表达式无法读取"></a>EL表达式无法读取</h3><p>在jsp中添加</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page isELIgnored=<span class="string">&quot;false&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><h3 id="js，css，html，png等静态文件无法使用"><a href="#js，css，html，png等静态文件无法使用" class="headerlink" title="js，css，html，png等静态文件无法使用"></a>js，css，html，png等静态文件无法使用</h3><p>其实是被Spring MVC拦截了</p><p>在 web.xml 中配置</p><p><img src="https://i.loli.net/2021/05/30/q7GDKL3EJnc5U6l.png" alt="img" loading="lazy"></p><p><a href="https://blog.csdn.net/gwd1154978352/article/details/54631455">https://blog.csdn.net/gwd1154978352/article/details/54631455</a></p><h3 id="数据库报错"><a href="#数据库报错" class="headerlink" title="数据库报错"></a>数据库报错</h3><p>Server returns invalid timezone. Need to set‘serverTimezone’property</p><p><img src="https://i.loli.net/2021/06/01/ABzFyDd3SKm76qG.png" alt="image-20210601141050121" loading="lazy"></p><p><img src="https://i.loli.net/2021/06/01/BeyWVHoOZlf7m5h.png" alt="image-20210601141112107" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> 报错 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL深度理解</title>
      <link href="mySql%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3/"/>
      <url>mySql%E6%B7%B1%E5%BA%A6%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>哪里不懂强烈建议查阅 <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a></p><h3 id="数据库查询"><a href="#数据库查询" class="headerlink" title="数据库查询"></a>数据库查询</h3><p>数据库查询表时，利用索引会使查询快很多，因为索引数据结构是已经排好序的。并且还有自己的数据结构特性，比如B+范围查询比较快，Hash单点查询比较快。</p><p>数据库查询时间分成两部分：</p><ol><li>对存放数据查询，系统需要对应磁盘块进行IO（极其占用时间）</li><li>对查询到的磁盘块里的数据二分查找确定目标数据</li></ol><p><strong>所以我们MySQL减少查询时间的主要手段就是减少IO次数，因此用B+树</strong></p><span id="more"></span><h3 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h3><p>二叉树  （只用一边时会退化成链表）</p><p>红黑树（层数过高，弃）</p><p><img src="https://i.loli.net/2021/05/31/k7CMSRKTtrY8dXv.png" alt="image-20210531180915450" loading="lazy"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">红黑树和自平衡二叉(查找)树区别</span><br><span class="line">  1、红黑树放弃了追求完全平衡，追求大致平衡，在与平衡二叉树的时间复杂度相差不大的情况下，保证每次插入最多只需要三次旋转就能达到平衡，实现起来也更为简单。</span><br><span class="line">  2、平衡二叉树追求绝对平衡，条件比较苛刻，实现起来比较麻烦，每次插入新节点之后需要旋转的次数不能预知。</span><br></pre></td></tr></table></figure><p>Hash表</p><p><img src="https://i.loli.net/2021/05/31/VQhH6T94EpvlUX2.png" alt="image-20210531191413946" loading="lazy"></p><p>B-Tree</p><p><img src="https://i.loli.net/2021/05/31/oskwHMY9D6OGWqS.png" alt="image-20210531181040381" loading="lazy"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">图解</span><br><span class="line">0.每个页大小是固定的，默认16kb，每页读取都需要磁盘IO</span><br><span class="line">1.中间空白的指针，指向子page对应磁盘空间的地址</span><br><span class="line">2.绿色的为索引元素，数字是排序的key，空白的是指针</span><br><span class="line">3.紫色的为data，相较于索引元素大很多</span><br><span class="line"></span><br><span class="line">B树相对于红黑树</span><br><span class="line">它的层数更低</span><br><span class="line">B树特点</span><br><span class="line">1.它的叶子节点之间不向后连接</span><br><span class="line">2.它的索引没有冗余</span><br><span class="line">3.它的索引对应着data（每一页储存的key变得很少，层数就会增多，IO次数就多）</span><br></pre></td></tr></table></figure><p>MySQL的B+Tree</p><p><img src="https://i.loli.net/2021/05/31/6p4kHFLGOtaRjoW.png" alt="image-20210531181838606" loading="lazy"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MySql的B+Tree</span><br><span class="line">0.每个页大小是固定的，默认16kb(够存储千万个的key)，每页读取都需要磁盘IO</span><br><span class="line">1.中间空白的指针，指向子page对应的磁盘空间的地址</span><br><span class="line">2.绿色的为索引元素，数字是排序的key，空白的是指针</span><br><span class="line">3.紫色的为data，相较于索引元素大很多</span><br><span class="line"></span><br><span class="line">MySql的B+Tree相比于B树</span><br><span class="line">1.它的叶子节点双向连接</span><br><span class="line">2.它的索引元素有冗余</span><br><span class="line">3.它的索引元素仅储存索引和指针（不存data，所以一页可以存很多key，层数就会减少，IO次数就少）</span><br></pre></td></tr></table></figure><p>注：传统的B+树</p><p><img src="https://i.loli.net/2021/05/31/iMRXUuJeaz5WkZV.png" alt="image-20210531182040014" loading="lazy"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">图解</span><br><span class="line">简单区分即可</span><br><span class="line">传统B+树的叶子节点，指向是单向的</span><br><span class="line">而mySql的B+树是双向的</span><br></pre></td></tr></table></figure><h3 id="储存引擎"><a href="#储存引擎" class="headerlink" title="储存引擎"></a>储存引擎</h3><p>常见两种储存引擎来存储/查询 <strong>表 表 表！！！</strong>：</p><p><img src="https://i.loli.net/2021/05/31/aQHqEuTVn5DhZwp.png" alt="image-20210531184622308" loading="lazy"></p><hr><p><img src="https://i.loli.net/2021/05/31/cyXaWAUuLrqJVIZ.png" alt="image-20210531185426559" loading="lazy"></p><p>MyISAM（frm,MYD,MYI）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">frm:表的framework,表的结构</span><br><span class="line">MYD：这个D就是表示Data</span><br><span class="line">MYI：这个I就是表示Index</span><br><span class="line">所以说他是非聚集性索引，因为MYI文件单独存储并维护索引，然后对应的叶子节点的data，其实是记录着指向MYD的对应数据磁盘块的指针。</span><br><span class="line">也就是说，即便读到了对应索引元素，也还需要IO来读取具体的Data</span><br></pre></td></tr></table></figure><p>InnoDB（frm,ibd）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">frm:表的framework,表的结构</span><br><span class="line">ibd：直接储存着索引元素并且叶子节点直接带着实际的Data</span><br><span class="line">因此说他是聚集性索引，因为读到了对应索引元素，就可以直接在当前磁盘块进行读取</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/05/31/86q7iU5lGy2F9BT.png" alt="image-20210531190133300" loading="lazy"></p><p><img src="https://i.loli.net/2021/05/31/6uxSgq2I3YwoBPU.png" alt="image-20210531191852670" loading="lazy"></p><h3 id="如果不建主键会发生什么"><a href="#如果不建主键会发生什么" class="headerlink" title="如果不建主键会发生什么"></a>如果不建主键会发生什么</h3><p>如果不建主键的话，MySQL数据库会自动找一个列来作为索引（这个列要符合每行数据都不相同）</p><p>如果找不到合适的列就会自己创建一个隐形的RowId列作为索引。</p><p>数据库的内存资源非常宝贵，我们不应该让他自己建立并维护索引</p><h3 id="为什么推荐使用整型的自增数据作为索引"><a href="#为什么推荐使用整型的自增数据作为索引" class="headerlink" title="为什么推荐使用整型的自增数据作为索引"></a>为什么推荐使用整型的自增数据作为索引</h3><p>首先我们知道B+树储存的索引元素里只储存key和下个page的指针。</p><p>如果你用字符串作为key，那么它占用的字节肯定是远远大于int的，</p><p>一方面它占用的硬盘空间变大，企业级的硬盘是一个高昂的开销</p><p>另一方面，每一个page存储的key变少了，层数和IO次数也就高了</p><p><strong>最重要的是，为了维护正确的索引结构，每改动以下包含索引的列，都会对索引文件进行对应改动。</strong></p><p><strong>根据如果你插入的顺序是自增的，那么只需要改动对应的一侧B+树，如果在较前的位置插入的话，整棵树可能都要发生改动。</strong></p><p>其次你二分查找时，对int进行比较肯定比对字符串高效的多</p><h3 id="为什么非主键索引结构叶子节点存储的是主键值"><a href="#为什么非主键索引结构叶子节点存储的是主键值" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值"></a>为什么非主键索引结构叶子节点存储的是主键值</h3><p>一致性和节省空间</p><h3 id="为什么建议使用联合索引"><a href="#为什么建议使用联合索引" class="headerlink" title="为什么建议使用联合索引"></a>为什么建议使用联合索引</h3><p>虽然索引可以提高查询效率，但是每次对数据进行改动时，都需要对索引文件进行对应的改动</p><h3 id="索引最左前缀"><a href="#索引最左前缀" class="headerlink" title="索引最左前缀"></a>索引最左前缀</h3><p>先按照name排序，name相同就排age，age相同就排position</p><p>注：下挂Data只有一个，说明是非主键的联合索引</p><p><img src="https://i.loli.net/2021/05/31/6dhUN1ZQnPSe8WD.png" alt="image-20210531192759217" loading="lazy"></p><p>下图只有第一条sql查询走的是联合索引。只有用到了联合索引的第一个索引时，才会走索引进行查询。</p><p>也就是说 联合索引如果是 name,age,position的话，只有查询用到了最左边的name，才会使用索引</p><p>并且如果联合索引也是有长度的，如果全用的话时满长度</p><p>从左到右，如果查询时有缺失时，则只用到了前面一部分的联合索引。</p><p>比如查询用到了 name 和 position，缺了中间的age，所以这次查询只用了联合索引的name部分</p><p><img src="https://i.loli.net/2021/05/31/kjJoht6xfG79KUO.png" alt="image-20210531193232733" loading="lazy"></p>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署</title>
      <link href="%E9%83%A8%E7%BD%B2/"/>
      <url>%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h3 id="生成静态文件"><a href="#生成静态文件" class="headerlink" title="生成静态文件"></a>生成静态文件</h3><p>至今我们的工作都是在本地进行，想必你也很想放到线上与小伙伴们分享。<br>这便轮到了 GitHub Pages 的出场，不过 GitHub Pages 只支持纯静态文件。</p><p>所以我们需要使用以下命令先来生成站点的静态文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果进行多次生成，为了避免受错误缓存影响，最好使用 hexo clean 先清除一遍。</span></span><br><span class="line">hexo generate</span><br><span class="line"><span class="comment"># 缩写为 hexo g</span></span><br></pre></td></tr></table></figure><p>此时你的文件夹目录下会出现 <code>public</code> 这个文件夹，里面存放的就是你站点的静态文件。</p><span id="more"></span><h3 id="与远程仓库建立关联"><a href="#与远程仓库建立关联" class="headerlink" title="与远程仓库建立关联"></a>与远程仓库建立关联</h3><p>接下来我们将本地的仓库与此前在 GitHub 上建立的仓库建立关联。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git init <span class="comment"># 初始化 Git 仓库，只需要执行一次即可</span></span><br><span class="line"><span class="comment">#Initialized empty Git repository in D:/Blog/.git/</span></span><br></pre></td></tr></table></figure><p>在将其部署到 GitHub Pages 上之前，我们最好先建立一个分支。</p><blockquote><p>什么是分支？<br>Git 提供了版本管理功能，其中还有一个分支功能，你现在可以简单地将其理解为平行世界。</p></blockquote><p><code>你的名字.github.io</code> 部署后，GitHub Pages 将默认使用你的 master 分支作为静态文件部署。<br>所以我们最好新建一个 hexo 分支（命名无所谓）用来存储 Hexo 地源代码，master 分支则用来存储部署后的静态文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b hexo</span><br><span class="line"><span class="comment">#Switched to a new branch &#x27;hexo&#x27;</span></span><br></pre></td></tr></table></figure><p>这时便成功建立了一个 hexo 分支。（此后的工作都将在 hexo 分支下进行）</p><p>你可以通过 <code>git branch -v</code> 来查看当前有哪些分支，使用 <code>git checkout 分支名</code> 来切换到对应的分支。</p><blockquote><p><a href="https://www.yunyoujun.cn/note/git-learn-note/">Git 学习笔记</a></p></blockquote><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>为了更方便的部署到 GitHub Pages，Hexo 提供了 <code>hexo-deployer-git</code> 插件。</p><p>老规矩，安装。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git</span><br></pre></td></tr></table></figure><p>在 <code>_config.yml</code> 中配置。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">你此前新建的仓库的链接</span> <span class="comment"># 比如：https://github.com/YunYouJun/yunyoujun.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span> <span class="comment"># 默认使用 master 分支</span></span><br><span class="line">  <span class="attr">message:</span> <span class="string">Update</span> <span class="string">Hexo</span> <span class="string">Static</span> <span class="string">Content</span> <span class="comment"># 你可以自定义此次部署更新的说明</span></span><br></pre></td></tr></table></figure><p>保存，部署！</p><blockquote><p>第一次可能需要你输入用户名与密码。<br>密码输入的时候不会出现 ***，不要害怕，已经输入进去了。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>等待完成后，打开网址 <code>https://你的名字.github.io</code> 就能看到你的线上网站了。</p><blockquote><p>使用 https，http 可能无法正常打开。HTTPS 是多了安全加密的 HTTP，Chrome 浏览器已经默认会显示 <code>http</code> 链接为不安全。<br>为了安全，建议开启强制 https 跳转。<code>项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Enforce HTTPS</code>。（翻到下面）<br>此时，http 网址会自动重定向到 https</p></blockquote><h3 id="备份与自动部署"><a href="#备份与自动部署" class="headerlink" title="备份与自动部署"></a>备份与自动部署</h3><p>我们当前只是将生成的静态文件部署到了云端。</p><p>为了以防万一，我们应该将网站的源代码文件也推送到 GitHub 仓库备份。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 与远程 Git 仓库建立连接，只此一次即可</span></span><br><span class="line">git remote add origin https://github.com/你的用户名/你的名字.github.io</span><br></pre></td></tr></table></figure><p>接下来准备提交，这几句命令将是你以后每次备份所需要输入。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 添加到缓存区</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;这次做了什么更改，简单描述下即可&quot;</span></span><br><span class="line"><span class="comment"># 推送至远程仓库</span></span><br><span class="line">git push</span><br><span class="line"><span class="comment"># 第一次提交，你可能需设置一下默认提交分支</span></span><br><span class="line"><span class="comment"># git push --set-upstream origin hexo</span></span><br></pre></td></tr></table></figure><p>每次推送都要输入这三条命令，你可能觉得有些麻烦。<br>那么你可以编写 bash 脚本。</p><p>譬如，在根目录下新建 <code>update.sh</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果没有消息后缀，默认提交信息为 `:pencil: update content`</span></span><br><span class="line">info=<span class="variable">$1</span></span><br><span class="line"><span class="keyword">if</span> [<span class="string">&quot;<span class="variable">$info</span>&quot;</span> = <span class="string">&quot;&quot;</span>];</span><br><span class="line"><span class="keyword">then</span> info=<span class="string">&quot;:pencil: update content&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">git add -A</span><br><span class="line">git commit -m <span class="string">&quot;<span class="variable">$info</span>&quot;</span></span><br><span class="line">git push origin hexo</span><br></pre></td></tr></table></figure><p>此后更新的话，只需要在终端执行 <code>sh update.sh</code> 即可。</p><p>更新麻烦，每次部署也很麻烦，可以使用持续集成进行自动部署。</p><blockquote><p>什么是持续集成？<br>持续集成是一种软件开发实践。对软件进行自动化构建，以此来发现错误。<br>Travis CI 就是一个线上持续集成服务的提供商。它可以拉取你每次推送到 GitHub 上的代码，然后根据你的要求对其进行构建。<br>我们可以趁机让它自动生成网站静态文件，然后自动帮我们部署。<br>除此之外，你还可以使用 <a href="https://help.github.com/en/actions/getting-started-with-github-actions/about-github-actions">GitHub Actions</a> ，<a href="https://www.netlify.com/">Netlify</a> 等服务。<br>GitHub Actions 相比 Travis 等，自身便拥有仓库的 Token，不再需要额外设置，可以直接使用 <code>secrets.GITHUB_TOKEN</code>。<br>推荐一个专门用来部署 gh-pages 的 Actions <a href="https://github.com/peaceiris/actions-gh-pages">actions-gh-pages</a></p></blockquote><p>关于更多更具体的自动化部署方案和操作步骤，你可以参考我的小伙伴 ChrAlpha 的 <a href="https://blog.ichr.me/post/automated-deployment-of-serverless-static-blog/">初探无后端静态博客自动化部署方案</a>。</p><p>他在文章中详细介绍了 Netlify 、GitHub Actions 和 Travis CI 的部署方法。</p><p>你也可以参考 Hexo 的官方文档 <a href="https://hexo.io/zh-cn/docs/github-pages">将 Hexo 部署到 GitHub Pages</a></p><p>我就不在此画蛇添足。</p><hr><p>当然还有个更简便的方法，直接参考我的 <a href="https://github.com/YunYouJun/yunyoujun.github.io/blob/hexo/.github/workflows/gh-pages.yml">gh-pages.yml</a>。</p><p>去掉夹在 <code>yarn install</code> 与 <code>yarn build</code> 之间的 <code>algolia</code> 部分，直接粘贴到你的 <code>.github/workflows/</code> 文件夹（自己新建）下 <code>xxx.yml</code> 文件里即可。</p><p>推送后便可直接自动部署。</p><p>至此，你的站点便基本搭建完成，此后继续对主题进行自定义吧。</p><blockquote><p><a href="https://yun.yunyoujun.cn/">Yun 主题文档</a></p></blockquote><h3 id="开始写作"><a href="#开始写作" class="headerlink" title="开始写作"></a>开始写作</h3><h4 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h4><p>输入以下命令即可新建 <code>xxx.md</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new post xxx</span><br></pre></td></tr></table></figure><blockquote><p><code>md</code> 是 <code>Markdown</code> 的后缀名，是一种简洁方便的文本标记语言。你只需要记住简单的几种语法，就可以快速进行编写。<br>为什么使用 Markdown？<br>首先 Hexo 本身就是将 Markdown 转化为静态的 Html 文件，来方便用户编写文章。<br>Markdown 就好似介于 Word 与 TXT 文本之间。Word 体积大、大部分功能实际上根本用不到，且最后的文档常常带有许多冗余信息。<br>而 TXT 却无法实现加粗、标题、下划线、水平分割线等常用的功能。<br>（这里所说的 TXT 只是一种纯文本格式的代称，实际上 Markdown 也是纯文本文件，不过通过语法和 Markdown 编译器，我们就可以看到一些简单的样式。）</p></blockquote><p>譬如本文就是通过 Markdown 编写。</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 一级标题</span></span><br><span class="line"></span><br><span class="line"><span class="section">## 二级标题</span></span><br><span class="line"></span><br><span class="line"><span class="strong">**加粗文字**</span></span><br></pre></td></tr></table></figure><blockquote><p>更多语法（虽然说是更多，但是其实也没多少）：<a href="https://github.com/younghz/Markdown">Markdown 基本语法</a></p></blockquote><p>这是我写的一个 Markdown 样式：<a href="https://www.yunyoujun.cn/star-markdown-css/">star-markdown-css</a></p><p>上面是渲染过后的效果，你可以与其 Markdown 的<a href="https://raw.githubusercontent.com/YunYouJun/star-markdown-css/master/demo/md/demo.md">纯文本原文</a>进行对比。</p><h5 id="添加标签-分类"><a href="#添加标签-分类" class="headerlink" title="添加标签/分类"></a>添加标签/分类</h5><p>例如本文 Markdown 的头部。</p><blockquote><p><a href="https://hexo.io/zh-cn/docs/front-matter.html">Front-matter</a></p></blockquote><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 教你如何从零开始搭建一个属于自己的网站</span><br><span class="line">date: 2020-03-05 01:31:08</span><br><span class="line">updated: 2020-07-14 16:31:00</span><br><span class="line">tags:</span><br><span class="line"><span class="bullet">  -</span> 教程</span><br><span class="line"><span class="bullet">  -</span> Hexo</span><br><span class="line"><span class="bullet">  -</span> 分享</span><br><span class="line">categories:</span><br><span class="line"><span class="section">  - 云游的小安利</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">你的文章内容</span><br></pre></td></tr></table></figure><h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><p>你可以新建一些自己的自定义页面。</p><p>譬如直接在 Hexo 目录下的 <code>source</code> 文件夹下直接新建 HTML 进行编写。</p><p>也可以通过以下命令来新建页面。（当然还是 Markdown，不过也是可以在 Markdown 里写 HTML 的，也会被渲染出来。）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page xxx</span><br></pre></td></tr></table></figure><p>说到这里，就不得不提一提本主题的特色功能了。</p><p>生成你的老婆列表页面。按一定格式书写即可。见<a href="https://yun.yunyoujun.cn/guide/page.html#girls">文档</a>。</p><blockquote><p>预览：<a href="https://www.yunyoujun.cn/girls/">Lovely Girls</a></p></blockquote><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="视频？"><a href="#视频？" class="headerlink" title="视频？"></a>视频？</h3><p>没有视频，一是懒，二是文字更利于更新勘误。</p><p>以及文章中将会频繁出现参考链接，更方便使用。</p><h3 id="如何绑定你的自定义域名？"><a href="#如何绑定你的自定义域名？" class="headerlink" title="如何绑定你的自定义域名？"></a>如何绑定你的自定义域名？</h3><p>首先，你得有个自己的域名。</p><blockquote><p>避免广告嫌疑，你可以自行前往相关域名提供商购买。<br><del>但是如果你有幸能看到谷歌广告（概率较小），可以考虑点一点。</del></p></blockquote><p>并使用 CNAME 解析到 <code>你的名字.github.io</code>。（当然 A 记录直接解析到 GitHub Pages IP 地址也可以。）</p><blockquote><p><a href="https://help.github.com/en/github/working-with-github-pages/managing-a-custom-domain-for-your-github-pages-site#configuring-an-apex-domain">Managing a custom domain for your GitHub Pages site</a></p></blockquote><p>在 <code>Hexo</code> 工作目录下 <code>source</code> 文件夹下新建 <code>CNAME</code> 文件（没有后缀名）。</p><blockquote><p>CNAME 即相当于告诉 GitHub 允许将 xxx.github.io 为你的域名提供服务。<br>source 目录下的文件除了特殊的 markdown 会被解析为 html，其余都会原样复制到生成的静态文件夹中。<br>所以你需要在 source 文件夹下建有 CNAME，它会在生成静态文件时，将 CNAME 拷贝到静态文件夹并部署到 master 分支。<br>如果只是在 GitHub 上设置（<code>项目地址页面 -&gt; Settings -&gt; Options -&gt; GitHub Pages -&gt; Custom domain</code>），它会自动添加到 master 分支上，但随后不包含 CNAME 的部署会将其覆盖。</p></blockquote><p>内容填写你的域名即可。</p><blockquote><p><a href="https://help.github.com/en/github/working-with-github-pages/about-custom-domains-and-github-pages">About custom domains and GitHub Pages</a></p></blockquote><h3 id="备案"><a href="#备案" class="headerlink" title="备案"></a>备案</h3><p>如果想要使用国内的一些服务，比如 CDN，不备案确实寸步难行。</p><p>此处我指的是 ICP 备案，并非公安备案。（实际上我从来没有进行过公安备案，且目前在使用服务时，并未受到任何相关限制。）</p><blockquote><p>我只在腾讯云备案过，所以只能分享一点此方面的经验。</p></blockquote><p>国内备案往往意味着你还需要一台国内的服务器，譬如通过腾讯云备案时会需要你设置关联的服务器（阿里云应当也是如此）。<br>实际上你的网站并不一定得在这台服务器上，即便你只是免费试用了一个月，但是备案成功了，之后过期了对备案也不会有何影响。</p><blockquote><p>也就是说你完全可以使用学生优惠（10 元左右）购买一个月的云服务器，用于关联，并在这个月内抓紧备案好，此后云服务器过期不会影响备案问题。<br>学生优惠的话 <a href="https://www.aliyun.com/minisite/goods?userCode=ixykjqj2">阿里云</a> 或者 <a href="https://url.cn/PLQYbz6n">腾讯云</a> 都有。</p></blockquote><p>备案前需要注意的几点就是：</p><ul><li>确定你的域名是否可以备案（一些少见/独特的域名后缀，国内是无法备案的，比如 <code>moe</code>）</li><li>关闭评论区</li><li>提交备案时的备注说明不得含有 <code>交流</code> 字样</li><li>首页不能含有其他网站的直达链接</li><li>遵纪守法无不良信息（这是当然的）</li></ul><p>你也可以直接关停网站，等待备案成功后再重新打开。（今后每年偶尔会复查，但相对会宽松许多。）</p><p>此后，按照网站指引的备案步骤一步步来即可。（以前还要等待幕布寄送拍照，现在可以直接在手机上人脸验证）</p><p>备案成功后页脚必须清晰地展示备案号，且备案号含有指向 <a href="http://www.beian.miit.gov.cn/">http://www.beian.miit.gov.cn/</a> 的超链接。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello-world</title>
      <link href="hello-world/"/>
      <url>hello-world/</url>
      
        <content type="html"><![CDATA[<p>模板用<br>type: bilibili<br>url: /Hello-World</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
